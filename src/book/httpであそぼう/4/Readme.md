# HTTP であそぼう part4

早くサーバーにしてよ って思ったので。

# 本日の一言

(公開時に埋める)

# TCP を取り扱おう

rust の標準クレートの一つ、net モジュールは優秀だと思います。  
おかげで簡単に通信ができるのです。

```rust, ignore
# use anyhow::{Result, anyhow};
# use std::{
#     collections::HashMap,
#     io::{Read, Write},
#     net::TcpListener,
# };
#
#
fn main() -> Result<()> {
    let listener = TcpListener::bind("0.0.0.0:80")?;
}
```

TcpListener インスタンスにある accept メソッドで、受信したパケットを受け取ることができます。

## ブロッキング

その前に、ブロッキングについて知っておく必要があります。  
関数は、極力成功するように作られています。 **処理を成功させるためなら無限に時間をとるものもあります。**  
例えば、時間のかかる補助記憶装置からの読み込み時にブロッキングされます。
通信であれば、**次のパケットを受け取るまでブロッキング**など。

## バッファ

バッファも知っておく必要があります。  
OS は一度、全ての通信をバッファに蓄えます。 そこから、アプリケーションごとに分配を行っていくのです。  
[linux だと sysctl で調整できます。](https://access.redhat.com/ja/solutions/504383)

なお、OS のバッファからデータを拾ってくるのは**アプリケーション側**です。  
アプリケーションがモタモタしてたら、OS のバッファを使い尽くしてしまいます。  
受信したパケットは素早く処理できるようにするのが理想です。

> [!NOTE]  
> Accept して read しないで待機しつつ、大量に通信送ってみたら、（つまり OS のバッファを埋めるように待っていたら）  
> いろんな通信ができなくなった経験がある。経験則。
