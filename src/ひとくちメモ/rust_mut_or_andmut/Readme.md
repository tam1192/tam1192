# &mut 型と let mut の違い

ふと気になってしまったため

# 🎵 今日に一曲は、ひとくちメモでは廃止します

ストックする曲数が減ってしまったため、廃止します。

# mut について

イミュータブルをミュータブルにするあれです。

`let`式に`mut`という語をつけると、値を束縛した変数がミュータブル（変更可能）となります。

## &mut 型について

```rust
# fn main() {
// 生の値
let mut i = 32;
println!("{}", i);
// 可変参照の値
let m = &mut i;
*m = 64;
println!("{}", i);
# }
```

`&mut`は、可変参照であることを示す。 `*`は参照外し記号である。

`*`を`&mut`に用いると、その一瞬だけ、**生の値が見えるようになる。**

```rust, ignore
let m = &mut i; // mはiの可変参照
let x = *m; // xとiは別物になる
```

別の変数で束縛すると、clone したという扱いとなり、別の値になってしまう。

```rust, ignore
let m = &mut i; // mはiの可変参照
*m = 64;
```

ここでは、

```rust, ignore
i = 64
```

と同義となる。

> [!NOTE]
> 本来参照が不要なところで使用しているため。  
> 参照が必要なところでこれを行うと、値を move してしまい、元のスコープで継続して使用できなくなってしまう

## 可変参照の制約

```rust, ignore
// 可変参照の値
let m = &mut i;
let n = &mut i; // mが無効になる
*m = 64; // mは無効なのでエラー
```

可変参照は、言語の制約によって**参照が一つまでに制限される。**
よって、上記のように宣言するのは NG だし

```rust
// 可変参照の値
let m = &mut i;
*m = 64;
println!("{}", i); // mの参照がまだ残ってるので、新たに参照が作れない
*m = 128;
```

~~別の関数を呼び出すことによって、参照を無効化してしまう恐れもある。~~
コンパイラー曰く「**m の参照が残ってるので新たに参照が作れない**」となるらしい。
