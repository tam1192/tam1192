# HTTP であそぼう part2

前回記事を作り込みすぎて後悔しました。
今回からフットワーク軽めで書きたいと思います。

## 本日の 1 曲 🎶

[レンズフレア - feat.音楽的同位体(V.I.P)](https://www.nicovideo.jp/watch/sm43424657)  
同位体 5 人の合唱曲。 かっこよすぎる。

## ★ について (★★★)

★ はこの記事の中でとりあえず読んで欲しいところに 3、自分用のメモレベルで 1 をつけてます。  
なので、★1 の内容が理解できなくても問題ないです! 書いてるやつが悪い。  
一方 ★3 は頑張って書きましたので読んで欲しいな〜

# 本題 (★★☆)

前回、HTTP の構文解析（パース）を行いました。  
これを使えば、受信したデータを HTTP をオブジェクトに直すことができ、データにアクセスが可能です。

とりあえず、これを使って通信を実現してみましょう。

## 擬似通信オブジェクトを作ってみる (★★☆)

擬似通信オブジェクト、つまり通信はしないが通信してるように見せかけるオブジェクトです。  
具体的には Read トレイトと Write トレイトを実装したオブジェクトです。

主な用途は記事やテスト用です。

```rust, ignore
{{#include ./code/src/vnet/mod.rs}}
```

長大なコードですが、その大半は~~AI 補完~~trait を実装すれば終わります。
内容の説明は至ってシンプルで、標準モジュールに存在する`TcpLisner`と`TcpStream`を最低限レベルで模しただけです。
そのため、`accept()`メソッドで通信を受信、`read()`や`write()`がそのまま使えます。

`accept()`で受信するデータを、キュー方式に対応した Vec `VecDeque` に格納しており、格納手段を提供するために `add_request()` メソッドを追加しております。
これは実際の`TcpLisner`とは異なるメソッドです。
`accept()`は、現実の動作を模すために、キューからデータが消えてもデータを待ち続けます。  
キューにデータが存在しない状態で`accept()`を実行すると、永遠に待つことになりますので注意。

テスト用に`get_write_data()`メソッドを提供してます。 これは`flush()`後でないと`None`を返します！

## 終わり

え、これだけかよ！  
はい。 前回内容が濃すぎたのを反省し、今回はここまでです。  
次回は擬似通信オブジェクトを活用して通信を楽しみたいと思います。
